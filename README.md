<a id="anchor1"></a>
# p2

<a id="anchor2"></a>
# 目次

  + [p2](#anchor1)
  + [目次](#anchor2)
  + [操作方法](#anchor3)
  + [制作環境](#anchor4)
  + [作成したコード](#anchor5)
  + [技術紹介](#anchor6)
    + [ポータルの作成方法](#anchor7)
    + [グラフィック](#anchor8)
  
<br>

<a id="anchor3"></a>
# 概要

+ **制作期間** <br>
    2023年10月～2024年2月

+ **制作人数** <br>
  1人

+ **ジャンル** <br>
  アクション・パズル

+ **プレイ人数** <br>
  1人

+ **対応機種**　<br>
  Windows 11
  
<br>

---
<a id="anchor3"></a>
# 操作方法

![guide](portfolio/guide.png)

+ Aボタン<br>
  + ジャンプ
  + 決定
+ Bボタン<br>
  + 戻る
+ Yボタン<br>
  + しゃがみ
+ RTボタン<br>
  + 発射(赤)
+ LTボタン<br>
  + 発射(青)
+ Lスティック<br>
  + 移動
+ Rスティック<br>
  + 回転

<br>

---
<a id="anchor4"></a>
# 制作環境

+ **使用ツール**<br>
  Visual Studio 2022 <br>
  Visual Studio Code <br>
  3ds Max 2023 <br>
  Adobe Photoshop 2022 <br>
  Effekseer <br>
  fork <br>
  Github

<br>

+ **使用言語**<br>
    C++<br>
    HLSL<br>

<br>

---
<a id="anchor5"></a>
# 作成したコード

**作成したコード**

+ PortalEngineプロジェクトの全て
+ Gameプロジェクトの全て

**改造したエンジンコード**

+ CharacterContoller.cpp
  + 天井への当たり判定処理(301行目～)


<br>

---
<a id="anchor6"></a>
# 技術紹介

<a id="anchor7"></a>
### **ポータルの作成方法**

+ 設置処理

  まずは、ポータルの設置位置を決めます。<br>
  プレイヤーの注視点から前方向にレイを飛ばし、衝突した壁の法線に沿ってポータルを設置します。

  <br>

+ ポータル越しのカメラ

  次に、ポータルから見える背景を描画します。

  まず、ポータルの位置にカメラを設置します。<br>
  このカメラの向きは、プレイヤーからもう一方のポータルに向かうベクトルと同じ方向になります。

  ![portal_0](portfolio/portal_0.png)
  ![portal_1](portfolio/portal_1.png)

  <br>

  この状態では、プレイヤーが移動したときに奥行き感のない背景が出来上がってしまいます。<br>
  なので、カメラの位置も考慮します。

  ![portal_2](portfolio/portal_2.png)

  <br>

  ポータルの背景というのは、プレイヤーの位置から見える景色を写しているはずです。<br>
  ですので、カメラの位置は、もう一方のポータルからプレイヤーに向かうベクトルと反対方向の位置になります。

  ![portal_5](portfolio/portal_5.png)

  <br>

  ここまででポータルの挙動を再現できました。<br>
  しかし、このままではポータルの向きが真反対の場合以外では、カメラが正しい向きになりません。

  ![portal_6](portfolio/portal_6.png)

  <br>

  ここで注目するのは、ポータル同士の向きです。
  カメラの位置や向きの計算結果は、回転を考慮していないベクトルになります。

  <br>

  ![portal_7](portfolio/portal_7.png)

  <br>


  ですので、予めポータル同士の向きをクォータニオンで保存し、計算時にベクトルに適用することで、向きの異なるポータル同士に対応したカメラになります。

  ![portal_8](portfolio/portal_8.png)

  <br>

+ 通過処理

  あとは、通過した際に、もう片方のポータルの位置にワープする処理を作るだけです。<br>
  しかし、このままでは壁があるので通過することができません。

  <br>

  このゲームでは、ポータルに触れている間、ポータルの当たり判定処理のみを実行することで、ポータルが壁をくり抜いているように表現しました。



<br>

<a id="anchor8"></a>
### **グラフィック**

+ PBR

  物理法則に従ったライティングの計算を行いました。物理法則に則った計算を実現するために、正規化Lambert拡散反射、フレネル拡散反射、Cook-Torranceを実装しました。

+ ディファードレンダリング

  無駄なピクセルのシェーダーを実行しないディファードレンダリングを採用することで、PBRなどの処理が重いシェーダーの実行回数を減らし、フレームレートの向上に繋げました。

  モデルの描画先をG-Bufferに描き込み、G-Bufferを使用してライティングの計算を行います。

  アルベド
  ![deferred_0](portfolio/deferred_0.png)

  法線
  ![deferred_1](portfolio/deferred_1.png)

  メタリックスムース
  ![deferred_2](portfolio/deferred_2.png)


+ ライトカリング

  ポイントライトなどの動的光源は、数が増えるごとに処理が重たくなっていきます。それを解決するために、TBR(Tile Based Rendering)を実装しました。TBRは、まずスクリーンをタイル状に分割し、タイル毎に影響を与える光源のリストを作成します。そして、動的光源の計算時に、そのタイルに影響を与えるライトのみで計算を行うことで、計算量を大幅に削減できます。

1. 射影空間でのZ値を出力するためのZPrepassを作成する。<br>
![lightCulling](portfolio/lightCulling_0.png)

2. タイルの視錐台を構成する6つの平面を求める。<br>

3. タイルとポイントライトの衝突判定を行う。<br>
  ライトの座標と平面の法線とで内積を使って、ライトと平面との距離を計算します。
  タイルと衝突していた場合、ポイントライトの番号を影響リストに積んでいきます。

4. 影響リストにライトの番号を記録していく。

5. 計算したライト番号を使って、各タイルに影響を与えるライト番号を使って、影響リストの開始位置と終了位置を計算する。